"use strict";
const __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../src/index");
const events_1 = require("events");
const readline_1 = require("readline");
/**
 * Implement relevant interfaces for console use
 */
class ConsoleVisual {
    constructor(text, newline) {
        this.text = text;
        this.newline = newline;
    }
}
class ConsoleMessage {
    constructor(message) {
        this.content = message;
    }
}
class ConsoleChannel {
    send(visual) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!visual.newline) {
                process.stdout.write(visual.text + ' ');
            }
            else {
                console.log(visual.text);
            }
            return new ConsoleMessage(visual.text);
        });
    }
}
class ConsolePrompt extends index_1.Prompt {
    static getRejectVisual(error) {
        return {
            text: `That's invalid input! (${error.message})`,
            newline: true
        };
    }
    // Implement abstract method. This should NOT be called
    // manually.
    onReject(error, message, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sendVisual(ConsolePrompt.getRejectVisual(error), channel);
        });
    }
    createCollector(channel, data) {
        const emitter = new events_1.EventEmitter();
        const readline = readline_1.createInterface({
            input: process.stdin,
            output: process.stdout
        });
        readline.on('line', (line) => {
            const message = new ConsoleMessage(line);
            if (line === 'exit') {
                // Exits are optional
                emitter.emit('exit', message);
            }
            else {
                // REQUIRED
                // but emitting messages are required
                emitter.emit('message', message);
            }
        });
        // REQUIRED
        emitter.once('stop', () => {
            readline.close();
        });
        return emitter;
    }
}
ConsolePrompt.exitVisual = {
    text: `No longer accepting input.`,
    newline: true
};
ConsolePrompt.inactivityVisual = {
    text: `You took too long.`,
    newline: true
};
// Ask name Prompt that collects messages
const askNameFn = function (m, data) {
    return __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, data), { name: m.content });
    });
};
const askName = new ConsolePrompt({
    text: `What's your name?`,
    newline: false
}, askNameFn, 2000);
// Ask age Prompt that collects messages
const askAgeFn = function (m, data) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isNaN(Number(m.content))) {
            throw new index_1.Rejection(`That's not a number!`);
        }
        return Object.assign(Object.assign({}, data), { age: Number(m.content) });
    });
};
const askAge = new ConsolePrompt((data) => __awaiter(void 0, void 0, void 0, function* () {
    return ({
        text: `How old are you, ${data.name}?`,
        newline: true
    });
}), askAgeFn);
// Conditional Prompt with no collector via undefined function
const tooOld = new ConsolePrompt((data) => __awaiter(void 0, void 0, void 0, function* () {
    return ({
        text: `Welcome ${data.name}, at ${data.age} you can freely drink.`
    });
}));
// Conditional Prompt with no collector via undefined function
const tooYoung = new ConsolePrompt((data) => __awaiter(void 0, void 0, void 0, function* () {
    return ({
        text: `Woah ${data.name}, at ${data.age} you can't drink yet.`
    });
}));
// Create the nodes. Prompts can be used by different nodes
const askNameNode = new index_1.PromptNode(askName);
const askAgeNode = new index_1.PromptNode(askAge);
const tooOldNode = new index_1.PromptNode(tooOld, (data) => __awaiter(void 0, void 0, void 0, function* () { return !!data.age && data.age > 21; }));
const tooYoungNode = new index_1.PromptNode(tooYoung, (data) => __awaiter(void 0, void 0, void 0, function* () { return !!data.age && data.age <= 21; }));
askNameNode.setChildren([askAgeNode]);
// Nodes with more than 1 sibling must have conditions defined
askAgeNode.setChildren([tooOldNode, tooYoungNode]);
// Message and messageCollectorCreator must be implemented by user
const runner = new index_1.PromptRunner({});
const channel = new ConsoleChannel();
runner.run(askNameNode, channel)
    .then(() => {
    console.log('complete');
})
    .catch(err => {
    console.log('jrere');
    // From the error listener of a prompt
    console.error(err);
});
