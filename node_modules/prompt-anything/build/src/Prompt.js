"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Rejection_1 = require("./errors/Rejection");
const PromptResult_1 = require("./PromptResult");
const UserInactivityError_1 = require("./errors/user/UserInactivityError");
const UserVoluntaryExitError_1 = require("./errors/user/UserVoluntaryExitError");
class Prompt {
    constructor(visualGenerator, f, duration = 0) {
        this.visualGenerator = visualGenerator;
        this.duration = duration;
        this.function = f;
    }
    /**
     * Returns the visual given the data
     *
     * @param data
     */
    getVisual(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.visualGenerator === 'function') {
                return this.visualGenerator(data);
            }
            else {
                return this.visualGenerator;
            }
        });
    }
    /**
     * Handles timeout and messages of a message colllector
     *
     * @param emitter Message collector
     * @param func Prompt function
     * @param data Prompt data
     * @param duration Duration of collector before it emits inactivity
     */
    static handleCollector(emitter, func, data, duration) {
        let timer;
        if (duration) {
            console.log('timmy');
            timer = setTimeout(() => {
                console.log('inactive');
                emitter.emit('inactivity');
            }, duration);
        }
        emitter.on('message', (thisMessage) => __awaiter(this, void 0, void 0, function* () {
            yield this.handleMessage(emitter, thisMessage, func, data);
        }));
        emitter.once('stop', () => {
            clearTimeout(timer);
            emitter.removeAllListeners();
        });
    }
    /**
     * Handle each individual message from a collector to determine
     * what event it should emit. Ignores all messages whose author
     * ID does not match the original message.
     *
     * @param emitter Message collector
     * @param message Collected message
     * @param func Prompt function
     * @param data Prompt data
     */
    static handleMessage(emitter, message, func, data) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
                // @ts-ignore
                const newData = yield func(message, data);
                emitter.emit('accept', message, newData);
            }
            catch (err) {
                if (err instanceof Rejection_1.Rejection) {
                    // Don't stop collector since rejects can be tried again
                    emitter.emit('reject', message, err);
                }
                else {
                    emitter.emit('error', err);
                }
            }
        });
    }
    /**
     * Send a visual
     *
     * @param visual The visual for channel.send to send
     * @param channel Channel to send the message to
     */
    sendVisual(visual, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(visual)) {
                const sent = [];
                for (const v of visual) {
                    const message = yield channel.send(v);
                    sent.push(message);
                }
                return sent;
            }
            else {
                const sent = yield channel.send(visual);
                return sent;
            }
        });
    }
    /**
     * Send the visual generated by the visual generator
     *
     * @param message The MessageInterface before this prompt
     * @param data Data to generate the user's message
     */
    sendUserVisual(channel, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sendVisual(yield this.getVisual(data), channel);
        });
    }
    /**
     * Runs the Prompt function for every message collected.
     * Reject when channel send promise rejects.
     *
     * @param channel The channel to collect from
     * @param data The data before this prompt
     */
    collect(channel, data) {
        return new Promise((resolve, reject) => {
            if (!this.function) {
                resolve(new PromptResult_1.PromptResult(data));
                return;
            }
            const collector = this.createCollector(channel, data);
            Prompt.handleCollector(collector, this.function, data, this.duration);
            const handleInternalError = (error) => collector.emit('error', error);
            // Internally handled events
            collector.once('error', (err) => {
                collector.emit('stop');
                reject(err);
            });
            collector.once('accept', (acceptMessage, acceptData) => {
                collector.emit('stop');
                resolve(new PromptResult_1.PromptResult(acceptData));
            });
            // User-overridden events
            collector.once('inactivity', () => {
                collector.emit('stop');
                console.log('inactivity emitted');
                reject(new UserInactivityError_1.UserInactivityError());
            });
            collector.once('exit', (exitMessage) => {
                collector.emit('stop');
                reject(new UserVoluntaryExitError_1.UserVoluntaryExitError());
            });
            collector.on('reject', (userInput, err) => {
                this.onReject(err, userInput, channel, data)
                    .catch(handleInternalError);
            });
        });
    }
    /**
     * Send the user's visual and start collecting messages
     *
     * @param channel The channel to collect from
     * @param data Data before this prompt
     */
    run(channel, data) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sendUserVisual(channel, data);
            return this.collect(channel, data);
        });
    }
}
exports.Prompt = Prompt;
