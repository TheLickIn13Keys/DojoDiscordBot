"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class PromptRunner {
    constructor(initialData) {
        this.ran = [];
        this.initialData = initialData;
    }
    /**
     * Checks whether the tree of nodes is valid. A valid tree
     * is one all children has a condition if there 2 or more
     * children.
     *
     * @param prompt Root prompt
     */
    static valid(prompt, seen = new Set()) {
        if (seen.has(prompt)) {
            return true;
        }
        if (!prompt.hasValidChildren()) {
            return false;
        }
        seen.add(prompt);
        const children = prompt.children;
        for (const child of children) {
            if (!this.valid(child, seen)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns the index of a prompt that have been executed
     * by this PromptRunner already
     *
     * @param prompt
     */
    indexOf(prompt) {
        return this.ran.indexOf(prompt);
    }
    /**
     * Returns the indexes of prompts that have been executed by
     * this PromptRunner already
     *
     * @param prompts Prompts to check index of
     * @returns {Array<number>} Array of indices
     */
    indexesOf(prompts) {
        return prompts.map(prompt => this.indexOf(prompt));
    }
    /**
     * Get the first node whose condition passes, given this
     * runner's initial data
     *
     * @param nodes Array of prompt nodes
     */
    getFirstNode(nodes) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < nodes.length; ++i) {
                const node = nodes[i];
                const condition = node.condition;
                if (!condition || (yield condition(this.initialData))) {
                    return node;
                }
            }
            return null;
        });
    }
    /**
     * Validate the node prompt and all its children before
     * executing
     *
     * @param rootNode Root prompt node
     * @param channel Channel to run the prompt in
     */
    run(rootNode, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!PromptRunner.valid(rootNode)) {
                throw new Error('Invalid rootNode found. Nodes with more than 1 child must have all its children have a condition function specified.');
            }
            return this.execute(rootNode, channel);
        });
    }
    /**
     * Get the first node whose condition passes, and run
     * it
     *
     * @param rootNode Root prompt node
     * @param channel Channel to run the root prompt node
     */
    runArray(rootNode, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            const matched = yield this.getFirstNode(rootNode);
            if (matched) {
                return this.run(matched, channel);
            }
            else {
                return this.initialData;
            }
        });
    }
    /**
     * Run the PromptNode without validating
     *
     * @param PromptNode Root prompt node
     * @param channel Channel
     */
    execute(rootNode, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            let thisNode = rootNode;
            let thisData = this.initialData;
            while (thisNode) {
                const thisPrompt = thisNode.prompt;
                const { data, terminate } = yield thisPrompt.run(channel, thisData);
                this.ran.push(thisNode.prompt);
                thisData = data;
                if (terminate) {
                    break;
                }
                thisNode = yield thisNode.getNext(data);
            }
            return thisData;
        });
    }
}
exports.PromptRunner = PromptRunner;
