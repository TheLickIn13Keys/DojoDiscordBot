"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiscordPrompt = void 0;
const prompt_anything_1 = require("prompt-anything");
const events_1 = require("events");
const MessageVisual_1 = require("./visuals/MessageVisual");
const MenuVisual_1 = require("./visuals/MenuVisual");
const DiscordRejection_1 = require("./types/DiscordRejection");
class DiscordPrompt extends prompt_anything_1.Prompt {
    // Visuals
    constructor(visualGenerator, f, duration = 90000) {
        super(visualGenerator, f, duration);
    }
    /**
     * Generate a MessageVisual to send based on the rejection thrown
     *
     * @param error The rejection thrown
     * @param message The message that triggered the rejection
     * @param channel The channel this rejection is to be sent to
     * @param data The data from the prompt
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getRejectVisual(error, message, channel, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (error instanceof DiscordRejection_1.DiscordRejection) {
                return new MessageVisual_1.MessageVisual(error.text, {
                    embed: error.embed
                });
            }
            else {
                return new MessageVisual_1.MessageVisual(error.message);
            }
        });
    }
    /**
     * Auto-generate the rejection on an invalid menu selection
     *
     * @param message The message that triggered this rejection
     * @param data The data from the prompt
     * @param menu The MenuEmbed that this prompt's visual component was created with
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static createMenuRejection(message, data, menu) {
        return new prompt_anything_1.Rejection('That is not a valid selection. Try again.');
    }
    // Override event
    onReject(error, message, channel, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const visual = yield this.constructor.getRejectVisual(error, message, channel, data);
            yield this.sendVisual(visual, channel);
        });
    }
    createEmitter() {
        return new events_1.EventEmitter();
    }
    createCollector(channel, data) {
        const discordChannel = channel;
        const emitter = this.createEmitter();
        const collector = discordChannel.channel.createMessageCollector(m => m.author.id === data.__authorID);
        collector.on('collect', (message) => __awaiter(this, void 0, void 0, function* () {
            /**
             * This will store only user input (because of the above filter)
             * Bot messages are stored within DiscordChannel send method
             */
            channel.storeMessages(message);
            this.handleMessage(message, data, emitter);
        }));
        emitter.once('stop', () => {
            collector.stop();
        });
        return emitter;
    }
    handleMessage(message, data, emitter) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Exit
                if (message.content === 'exit') {
                    emitter.emit('exit');
                    return;
                }
                // Check if MenuVisual for special handling
                const visual = yield this.getVisual(data);
                if (visual instanceof MenuVisual_1.MenuVisual) {
                    this.handleMenuMessage(message, data, visual.menu, emitter);
                }
                else {
                    emitter.emit('message', message);
                }
            }
            catch (err) {
                emitter.emit('error', err);
            }
        });
    }
    handleMenuMessage(message, data, menu, emitter) {
        if (!menu.isValidSelection(message.content)) {
            const rejection = this.constructor.createMenuRejection(message, data, menu);
            emitter.emit('reject', message, rejection);
        }
        else {
            emitter.emit('message', message);
        }
    }
}
exports.DiscordPrompt = DiscordPrompt;
