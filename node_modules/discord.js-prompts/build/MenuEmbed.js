"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MenuEmbed = void 0;
const discord_js_1 = require("discord.js");
class MenuEmbed {
    constructor(embed, settings = {}) {
        this.embed = new discord_js_1.MessageEmbed();
        this.options = [];
        /**
         * The current page
         */
        this.page = 0;
        this.paginationTimeout = 90000;
        this.maxPerPage = 5;
        this.multiSelect = false;
        if (embed) {
            this.embed = embed;
        }
        if (settings.maxPerPage !== undefined) {
            this.maxPerPage = settings.maxPerPage;
        }
        if (settings.paginationTimeout !== undefined) {
            this.paginationTimeout = settings.paginationTimeout;
        }
        if (settings.multiSelect !== undefined) {
            this.multiSelect = settings.multiSelect;
        }
    }
    /**
       * Get array of numbers of a range, separated by "-"
       *
       * @param string
       */
    static getMultiSelectOptionRange(string) {
        const split = string.split('-');
        const start = Number(split[0]);
        const end = Number(split[split.length - 1]);
        if (isNaN(start) || isNaN(end)) {
            return [];
        }
        const numbers = [];
        for (let i = start; i <= end; ++i) {
            numbers.push(i);
        }
        return numbers;
    }
    /**
     * Get comma-separated values for multi-select.
     *
     * @param string Input string
     */
    static getMultiSelectOptions(string) {
        const values = string.split(',').map(s => s.trim());
        const ranges = values.map(v => this.getMultiSelectOptionRange(v)).flat(1);
        return ranges.filter((val, index) => ranges.indexOf(val) === index);
    }
    /**
     * Enable pagination by defining an error handler for
     * when the menu fails to set up pages (when message
     * edits or reactions fail)
     *
     * @param errorHandler Error handler
     */
    enablePagination(errorHandler) {
        this.paginationErrorHandler = errorHandler;
        return this;
    }
    /**
     * Add an auto-numbered field
     *
     * @param name Name of option
     * @param description Description of optino
     * @param number Optionally override the numbering
     */
    addOption(name, description = '\u200b', number) {
        const count = this.numberOfOptions();
        this.options.push({
            name: `${number !== null && number !== void 0 ? number : count + 1}) ${name}`,
            description
        });
        return this;
    }
    /**
     * Enable multi selection for this menu
     */
    enableMultiSelect() {
        this.multiSelect = true;
        return this;
    }
    /**
     * Disable multi selection for this menu
     */
    disableMultiSelect() {
        this.multiSelect = false;
        return this;
    }
    /**
     * Return the number of options this embed has
     */
    numberOfOptions() {
        return this.options.length;
    }
    /**
     * Returns whether a number is out of range for the
     * options of this menu
     *
     * @param number Option number
     */
    isValidOption(number) {
        if (isNaN(number)) {
            return false;
        }
        return number <= this.numberOfOptions() && number > 0;
    }
    /**
     * Returns if a message content correctly identifies
     * an option of this menu
     *
     * @param content Message content
     */
    isValidSelection(content) {
        if (!this.multiSelect) {
            return this.isValidOption(Number(content));
        }
        else {
            const numbers = MenuEmbed.getMultiSelectOptions(content);
            return numbers.every(val => this.isValidOption(val));
        }
    }
    /**
     * Check if the current page is the last page
     */
    isOnLastPage() {
        return this.maxPerPage * (this.page + 1) >= this.numberOfOptions();
    }
    /**
     * Check if the current page is the first page
     */
    isOnFirstPage() {
        return this.page === 0;
    }
    /**
     * Increment the page and update the message if the
     * current page is not the last
     */
    nextPage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isOnLastPage()) {
                return this;
            }
            ++this.page;
            yield this.setMessage(message);
            return this;
        });
    }
    /**
     * Decrement the page and update the message if the
     * current page is not the first
     */
    prevPage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isOnFirstPage()) {
                return this;
            }
            --this.page;
            yield this.setMessage(message);
            return this;
        });
    }
    /**
     * Edit a message to show the current page
     *
     * @param message Message to update
     */
    setMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            // toJSON must be used, it fails otherwise for some reason
            yield message.edit('', {
                embed: this.getEmbedOfPage(this.page).toJSON()
            });
        });
    }
    /**
     * If this menu should enable pagination
     */
    canPaginate() {
        return this.spansMultiplePages() && !!this.paginationErrorHandler;
    }
    /**
     * Sets up pagination on a message
     *
     * @param message Channel to send to
     */
    setUpPagination(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.paginationErrorHandler) {
                throw new TypeError('Error handler for pagination is undefined');
            }
            try {
                /**
                 * The message must be cached for it to be referenced
                 * later by the reaction collector. This is required
                 * if all messages are not cached by default.
                 */
                message.channel.messages.cache.set(message.id, message);
                yield message.react('◀');
                yield message.react('▶');
                this.createReactionCollector(message);
            }
            catch (err) {
                this.paginationErrorHandler(err, message);
            }
        });
    }
    /**
     * Collect reactions for pagination for this menu
     *
     * @param message Message to collect reactions on
     */
    createReactionCollector(message) {
        if (!this.paginationErrorHandler) {
            throw new TypeError('Error handler for pagination is undefined');
        }
        const errorHandler = this.paginationErrorHandler;
        const filter = (r) => {
            return r.emoji.name === '◀' || r.emoji.name === '▶';
        };
        const collector = message.createReactionCollector(filter, {
            time: this.paginationTimeout
        });
        collector.on('collect', (reaction, user) => {
            if (user.bot) {
                return;
            }
            const name = reaction.emoji.name;
            if (name === '◀') {
                this.prevPage(message).catch(err => {
                    errorHandler(err, message);
                });
            }
            else if (name === '▶') {
                this.nextPage(message).catch(err => {
                    errorHandler(err, message);
                });
            }
        });
    }
    /**
     * Get the options of a page
     *
     * @param page
     */
    getOptionsOfPage(page) {
        if (!this.maxPerPage) {
            return this.options;
        }
        const startField = page * this.maxPerPage;
        return this.options.slice(startField, startField + this.maxPerPage);
    }
    /**
     * Get the embed that corresponds to a page number
     *
     * @param page
     */
    getEmbedOfPage(page) {
        const newEmbed = new discord_js_1.MessageEmbed(this.embed);
        const options = this.getOptionsOfPage(page);
        for (const option of options) {
            newEmbed.addField(option.name, option.description);
        }
        return newEmbed;
    }
    /**
     * Check if the number of fields spans across multiple pages
     */
    spansMultiplePages() {
        if (!this.maxPerPage) {
            return false;
        }
        return this.numberOfOptions() / this.maxPerPage > 1;
    }
}
exports.MenuEmbed = MenuEmbed;
