"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const DiscordPrompt_1 = require("../DiscordPrompt");
const prompt_anything_1 = require("prompt-anything");
const DiscordPromptRunner_1 = require("../DiscordPromptRunner");
const events_1 = require("events");
const DiscordChannel_1 = require("../DiscordChannel");
const MenuVisual_1 = require("../visuals/MenuVisual");
const MenuEmbed_1 = require("../MenuEmbed");
const MessageVisual_1 = require("../visuals/MessageVisual");
function flushPromises() {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => {
            setImmediate(resolve);
        });
    });
}
const createMockTextChannel = () => ({
    id: '',
    send: jest.fn(),
    createMessageCollector: jest.fn()
});
const createMockAuthor = (authorID) => ({
    id: authorID
});
const createMockMessage = (authorID, content = '') => ({
    content,
    author: {
        id: authorID
    },
    channel: {
        messages: {
            cache: new Map()
        }
    },
    edit: jest.fn(),
    react: jest.fn(),
    createReactionCollector: jest.fn()
});
const createMockReaction = (name) => ({
    emoji: {
        name
    }
});
describe('E2E tests', () => {
    const authorID = 'wse4rye35th';
    let author;
    let emit;
    let collectorStop;
    let emitter;
    let collector;
    let textChannel;
    let channel;
    beforeEach(() => {
        jest.restoreAllMocks();
        author = createMockAuthor(authorID);
        emitter = new events_1.EventEmitter();
        emit = jest.spyOn(emitter, 'emit');
        collectorStop = jest.fn();
        collector = new events_1.EventEmitter();
        Object.defineProperty(collector, 'stop', {
            value: collectorStop
        });
        jest.spyOn(DiscordPrompt_1.DiscordPrompt.prototype, 'createEmitter')
            .mockReturnValue(emitter);
        textChannel = createMockTextChannel();
        const createMessageCollector = textChannel.createMessageCollector;
        createMessageCollector.mockImplementation((filter) => {
            collector.on('tryCollect', (m) => {
                if (filter(m)) {
                    collector.emit('collect', m);
                }
            });
            return collector;
        });
        channel = new DiscordChannel_1.DiscordChannel(textChannel);
        jest.spyOn(DiscordPromptRunner_1.DiscordPromptRunner, 'convertTextChannel')
            .mockReturnValue(channel);
    });
    afterEach(() => {
        collector.removeAllListeners();
        emitter.removeAllListeners();
    });
    it(`ignores messages that are not from the author`, () => __awaiter(void 0, void 0, void 0, function* () {
        const askNameFn = (m, data) => __awaiter(void 0, void 0, void 0, function* () {
            return Object.assign(Object.assign({}, data), { name: m.content });
        });
        const askNameVisual = new MessageVisual_1.MessageVisual('What is your name?');
        const askName = new DiscordPrompt_1.DiscordPrompt(askNameVisual, askNameFn);
        const askNameNode = new prompt_anything_1.PromptNode(askName);
        const runner = new DiscordPromptRunner_1.DiscordPromptRunner(author, {});
        runner.run(askNameNode, textChannel);
        // Wait for all pending promise callbacks to be executed for the emitter to set up
        yield flushPromises();
        // Simulate unauthorized user input
        collector.emit('tryCollect', createMockMessage(authorID + 'aedg'));
        yield flushPromises();
        expect(emit).not.toHaveBeenCalledWith('message');
        // Simulate authorized user input
        const collectedMessage = createMockMessage(authorID);
        collector.emit('tryCollect', collectedMessage);
        yield flushPromises();
        expect(emit).toHaveBeenCalledWith('message', collectedMessage);
    }));
    it(`rejects when message is exit`, () => __awaiter(void 0, void 0, void 0, function* () {
        const askNameFn = (m, data) => __awaiter(void 0, void 0, void 0, function* () {
            return Object.assign(Object.assign({}, data), { name: m.content });
        });
        const askNameVisual = new MessageVisual_1.MessageVisual('What is your name?');
        const askName = new DiscordPrompt_1.DiscordPrompt(askNameVisual, askNameFn);
        const askNameNode = new prompt_anything_1.PromptNode(askName);
        const runner = new DiscordPromptRunner_1.DiscordPromptRunner(author, {});
        const run = runner.run(askNameNode, textChannel);
        // Wait for all pending promise callbacks to be executed for the emitter to set up
        yield flushPromises();
        const exitMessage = createMockMessage(authorID, 'exit');
        collector.emit('tryCollect', exitMessage);
        yield expect(run).rejects.toThrow(prompt_anything_1.Errors.UserVoluntaryExitError);
        expect(emit).toHaveBeenCalledWith('exit');
        expect(collectorStop).toHaveBeenCalled();
    }));
    it(`automatically rejects menu input`, () => __awaiter(void 0, void 0, void 0, function* () {
        const selectOptionFn = (m, data) => __awaiter(void 0, void 0, void 0, function* () {
            return Object.assign(Object.assign({}, data), { name: m.content });
        });
        const menu = new MenuEmbed_1.MenuEmbed()
            .addOption('a', 'b')
            .addOption('a', 'b')
            .addOption('a', 'b');
        const menuVisual = new MenuVisual_1.MenuVisual(menu);
        const selectOption = new DiscordPrompt_1.DiscordPrompt(menuVisual, selectOptionFn);
        const selectOptionNode = new prompt_anything_1.PromptNode(selectOption);
        const runner = new DiscordPromptRunner_1.DiscordPromptRunner(author, {});
        runner.run(selectOptionNode, textChannel);
        yield flushPromises();
        // Invalid option selection
        const invalidMessage = createMockMessage(authorID, '4');
        collector.emit('tryCollect', invalidMessage);
        yield flushPromises();
        expect(emit.mock.calls[0][0]).toEqual('reject');
        expect(emit.mock.calls[0][1]).toEqual(invalidMessage);
        expect(emit.mock.calls[0][2]).toBeInstanceOf(prompt_anything_1.Rejection);
        // Valid option selection
        const validMessage = createMockMessage(authorID, '3');
        collector.emit('tryCollect', validMessage);
        yield flushPromises();
        expect(emit.mock.calls[1][0]).toEqual('message');
        expect(emit.mock.calls[1][1]).toEqual(validMessage);
    }));
    it('changes embed to the next page with MenuEmbed', () => __awaiter(void 0, void 0, void 0, function* () {
        const selectOptionFn = (m, data) => __awaiter(void 0, void 0, void 0, function* () {
            return Object.assign(Object.assign({}, data), { name: m.content });
        });
        const menu = new MenuEmbed_1.MenuEmbed(undefined, { maxPerPage: 1 })
            .addOption('option1', 'd')
            .addOption('option2', 'd')
            .addOption('option3', 'd')
            .enablePagination(err => {
            throw err;
        });
        const nextPage = jest.spyOn(menu, 'nextPage');
        const menuVisual = new MenuVisual_1.MenuVisual(menu);
        const selectOption = new DiscordPrompt_1.DiscordPrompt(menuVisual, selectOptionFn);
        const selectOptionNode = new prompt_anything_1.PromptNode(selectOption);
        const runner = new DiscordPromptRunner_1.DiscordPromptRunner(author, {});
        // Create mocks
        const reactableMessage = createMockMessage(authorID);
        const createReactionCollector = reactableMessage.createReactionCollector;
        const reactCollector = new events_1.EventEmitter();
        createReactionCollector.mockImplementation((filter) => {
            reactCollector.on('tryCollect', (r, user) => {
                if (filter(r)) {
                    reactCollector.emit('collect', r, user);
                }
            });
            return reactCollector;
        });
        const textChannelSend = textChannel.send;
        textChannelSend.mockResolvedValue(reactableMessage);
        // Run
        const run = runner.run(selectOptionNode, textChannel);
        yield flushPromises();
        // React
        const nextEmoji = createMockReaction('â–¶');
        const reactor = createMockAuthor(authorID);
        reactCollector.emit('tryCollect', nextEmoji, reactor);
        yield flushPromises();
        // Check nextPage was called
        expect(nextPage).toHaveBeenCalledTimes(1);
        const edit = reactableMessage.edit;
        expect(edit).toHaveBeenCalledWith('', {
            embed: expect.objectContaining({
                fields: [{
                        name: '2) option2',
                        value: 'd',
                        inline: false
                    }]
            })
        });
        // Clean up
        reactCollector.removeAllListeners();
        emitter.emit('exit');
        yield expect(run).rejects.toThrow(prompt_anything_1.Errors.UserVoluntaryExitError);
    }));
});
