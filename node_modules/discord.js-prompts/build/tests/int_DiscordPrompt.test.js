"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const DiscordPrompt_1 = require("../DiscordPrompt");
const MessageVisual_1 = require("../visuals/MessageVisual");
const prompt_anything_1 = require("prompt-anything");
const MenuVisual_1 = require("../visuals/MenuVisual");
const MenuEmbed_1 = require("../MenuEmbed");
function flushPromises() {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => {
            setImmediate(resolve);
        });
    });
}
class MockCollector extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.stop = jest.fn();
    }
}
describe('Int::DiscordPrompt', () => {
    let visual;
    let prompt;
    afterEach(function () {
        jest.resetAllMocks();
    });
    beforeEach(() => {
        visual = new MessageVisual_1.MessageVisual('aedsg');
        prompt = new DiscordPrompt_1.DiscordPrompt(visual);
    });
    describe('createCollector', () => {
        let createdCollector;
        const discordChannel = {
            channel: {
                createMessageCollector: jest.fn()
            },
            storeMessages: jest.fn()
        };
        beforeEach(() => {
            createdCollector = new MockCollector();
            discordChannel.channel.createMessageCollector = jest.fn()
                .mockReturnValue(createdCollector);
        });
        it('emits a message for non-menu visuals', () => __awaiter(void 0, void 0, void 0, function* () {
            const returned = prompt.createCollector(discordChannel, {
                __authorID: 'af'
            });
            const emit = jest.spyOn(returned, 'emit');
            const message = {
                content: 'hello world'
            };
            createdCollector.emit('collect', message);
            yield flushPromises();
            expect(emit).toHaveBeenCalledWith('message', message);
        }));
        it('emits exit when message content is exit', () => {
            const returned = prompt.createCollector(discordChannel, {
                __authorID: 'srfh'
            });
            const emit = jest.spyOn(returned, 'emit');
            const message = {
                content: 'exit'
            };
            createdCollector.emit('collect', message);
            expect(emit).toHaveBeenCalledWith('exit');
        });
        it('emits a message when valid input for menu', () => __awaiter(void 0, void 0, void 0, function* () {
            const menu = new MenuEmbed_1.MenuEmbed();
            jest.spyOn(menu, 'isValidSelection')
                .mockReturnValue(true);
            const menuVisual = new MenuVisual_1.MenuVisual(menu);
            prompt = new DiscordPrompt_1.DiscordPrompt(menuVisual, () => __awaiter(void 0, void 0, void 0, function* () { return ({}); }));
            jest.spyOn(prompt, 'getVisual')
                .mockResolvedValue(menuVisual);
            const returned = prompt.createCollector(discordChannel, {
                __authorID: 'sed'
            });
            const emit = jest.spyOn(returned, 'emit');
            const message = {
                content: '1'
            };
            createdCollector.emit('collect', message);
            yield flushPromises();
            expect(emit).toHaveBeenCalledWith('message', message);
        }));
        it('emits a reject when invalid input for menu', () => __awaiter(void 0, void 0, void 0, function* () {
            const menu = new MenuEmbed_1.MenuEmbed();
            jest.spyOn(menu, 'isValidSelection')
                .mockReturnValue(false);
            const menuVisual = new MenuVisual_1.MenuVisual(menu);
            prompt = new DiscordPrompt_1.DiscordPrompt(menuVisual, () => __awaiter(void 0, void 0, void 0, function* () { return ({}); }));
            jest.spyOn(prompt, 'getVisual')
                .mockResolvedValue(menuVisual);
            const returned = prompt.createCollector(discordChannel, {
                __authorID: 'sryhdet'
            });
            const emit = jest.spyOn(returned, 'emit');
            const message = {
                content: '2'
            };
            createdCollector.emit('collect', message);
            yield flushPromises();
            expect(emit).toHaveBeenCalledWith('reject', message, new prompt_anything_1.Rejection('That is not a valid selection. Try again.'));
        }));
    });
});
