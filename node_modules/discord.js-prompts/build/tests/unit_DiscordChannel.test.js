"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const DiscordChannel_1 = require("../DiscordChannel");
const MenuVisual_1 = require("../visuals/MenuVisual");
const MenuEmbed_1 = require("../MenuEmbed");
const MessageVisual_1 = require("../visuals/MessageVisual");
jest.mock('../MenuEmbed');
jest.mock('../visuals/MessageVisual');
jest.mock('../visuals/MenuVisual');
describe('Unit::DiscordChannel', () => {
    afterEach(() => {
        jest.resetAllMocks();
    });
    describe('constructor', () => {
        it('initializes the channel', () => {
            const textChannel = {
                id: 'aedstgr'
            };
            const channel = new DiscordChannel_1.DiscordChannel(textChannel);
            expect(channel.channel).toEqual(textChannel);
        });
        it('initializes ID', () => {
            const textChannel = {
                id: 'aedstgr'
            };
            const channel = new DiscordChannel_1.DiscordChannel(textChannel);
            expect(channel.id).toEqual(textChannel.id);
        });
    });
    describe('DEFAULT OPTIONS', () => {
        it('returns correctly', () => {
            expect(DiscordChannel_1.DiscordChannel.DEFAULT_OPTIONS).toEqual({
                allowedMentions: {
                    parse: []
                }
            });
        });
    });
    describe('storeMessages', () => {
        it('stores a message', () => {
            const message = {
                foo: 'bar'
            };
            const textChannel = {};
            const discordChannel = new DiscordChannel_1.DiscordChannel(textChannel);
            discordChannel.messages.push({ a: 'b' });
            discordChannel.storeMessages(message);
            expect(discordChannel.messages[1]).toEqual(message);
        });
        it('stores an array of messages', () => {
            const messages = [{
                    foo: 'bar'
                }, {
                    foo: 'baz'
                }];
            const textChannel = {};
            const discordChannel = new DiscordChannel_1.DiscordChannel(textChannel);
            discordChannel.messages.push({ a: 'b' });
            discordChannel.storeMessages(messages);
            expect(discordChannel.messages[1]).toEqual(messages[0]);
            expect(discordChannel.messages[2]).toEqual(messages[1]);
        });
    });
    describe('sendMenuVisual', () => {
        it('sends correctly', () => __awaiter(void 0, void 0, void 0, function* () {
            const menuEmbed = new MenuEmbed_1.MenuEmbed();
            const options = Object.assign(Object.assign({}, DiscordChannel_1.DiscordChannel.DEFAULT_OPTIONS), { foo: 'bar', ho: 'dunk' });
            // Create the visual
            const menuVisual = new MenuVisual_1.MenuVisual(menuEmbed, options);
            menuVisual.menu = menuEmbed;
            menuVisual.options = options;
            // Create the channel
            const createdMessage = { b: 2 };
            const textChannel = {
                send: jest.fn().mockResolvedValue(createdMessage)
            };
            const discordChannel = new DiscordChannel_1.DiscordChannel(textChannel);
            discordChannel.channel = textChannel;
            // Send it
            const returned = yield discordChannel.sendMenuVisual(menuVisual);
            expect(textChannel.send).toHaveBeenCalledWith('', Object.assign(Object.assign({}, options), { embed: menuEmbed.embed }));
            expect(returned).toEqual(createdMessage);
        }));
        it('sets up pagination if eligible', () => __awaiter(void 0, void 0, void 0, function* () {
            const menuEmbed = new MenuEmbed_1.MenuEmbed();
            jest.spyOn(menuEmbed, 'canPaginate').mockReturnValue(true);
            const setUpPagination = jest.spyOn(menuEmbed, 'setUpPagination')
                .mockImplementation();
            // Create the visual
            const menuVisual = new MenuVisual_1.MenuVisual(menuEmbed);
            menuVisual.menu = menuEmbed;
            // Create the channel
            const textChannel = {
                send: jest.fn().mockResolvedValue({})
            };
            const discordChannel = new DiscordChannel_1.DiscordChannel(textChannel);
            discordChannel.channel = textChannel;
            // Send it
            yield discordChannel.sendMenuVisual(menuVisual);
            expect(setUpPagination).toHaveBeenCalled();
        }));
        it('does not set up pagination if ineligible', () => __awaiter(void 0, void 0, void 0, function* () {
            const menuEmbed = new MenuEmbed_1.MenuEmbed();
            jest.spyOn(menuEmbed, 'canPaginate').mockReturnValue(false);
            const setUpPagination = jest.spyOn(menuEmbed, 'setUpPagination')
                .mockImplementation();
            // Create the visual
            const menuVisual = new MenuVisual_1.MenuVisual(menuEmbed);
            menuVisual.menu = menuEmbed;
            // Create the channel
            const textChannel = {
                send: jest.fn().mockResolvedValue({})
            };
            const discordChannel = new DiscordChannel_1.DiscordChannel(textChannel);
            discordChannel.channel = textChannel;
            // Send it
            yield discordChannel.sendMenuVisual(menuVisual);
            expect(setUpPagination).not.toHaveBeenCalled();
        }));
    });
    describe('sendMessageVisual', () => {
        it('sends correctly', () => __awaiter(void 0, void 0, void 0, function* () {
            const text = 'aedgts';
            const options = Object.assign(Object.assign({}, DiscordChannel_1.DiscordChannel.DEFAULT_OPTIONS), { foo: 'bar', a: 1 });
            // Create the visual
            const visual = new MessageVisual_1.MessageVisual(text, options);
            visual.text = text;
            visual.options = options;
            // Create the channel
            const createdMessage = { a: 1 };
            const textChannel = {
                send: jest.fn().mockResolvedValue(createdMessage)
            };
            const discordChannel = new DiscordChannel_1.DiscordChannel(textChannel);
            discordChannel.channel = textChannel;
            // Send it
            const returned = yield discordChannel.sendMessageVisual(visual);
            expect(textChannel.send).toHaveBeenCalledWith(text, options);
            expect(returned).toEqual(createdMessage);
        }));
    });
    describe('send', () => {
        it('throws if it is not a MenuVisual or MessageVisual', () => __awaiter(void 0, void 0, void 0, function* () {
            const discordChannel = new DiscordChannel_1.DiscordChannel({});
            yield expect(discordChannel.send({
                text: 'hi'
            })).rejects.toThrow(TypeError);
        }));
        it('calls sendMenuVisual if visual is MenuVisual', () => __awaiter(void 0, void 0, void 0, function* () {
            const visual = new MenuVisual_1.MenuVisual(new MenuEmbed_1.MenuEmbed());
            // Create the channel
            const discordChannel = new DiscordChannel_1.DiscordChannel({});
            const createdMessage = {
                content: 'bar'
            };
            // Mock the method
            const sendMenuVisual = jest.spyOn(discordChannel, 'sendMenuVisual')
                .mockResolvedValue(createdMessage);
            // Send
            const returned = yield discordChannel.send(visual);
            expect(sendMenuVisual).toHaveBeenCalledWith(visual);
            expect(returned).toEqual(createdMessage);
        }));
        it('calls sendMenuVisual if visual is MessageVisual', () => __awaiter(void 0, void 0, void 0, function* () {
            const visual = new MessageVisual_1.MessageVisual('aedsgrf');
            // Create the channel
            const discordChannel = new DiscordChannel_1.DiscordChannel({});
            const createdMessage = {
                content: 'bar'
            };
            // Mock the method
            const sendMenuVisual = jest.spyOn(discordChannel, 'sendMessageVisual')
                .mockResolvedValue(createdMessage);
            // Send
            const returned = yield discordChannel.send(visual);
            expect(sendMenuVisual).toHaveBeenCalledWith(visual);
            expect(returned).toEqual(createdMessage);
        }));
        it('saves the message for sendMessageVisual', () => __awaiter(void 0, void 0, void 0, function* () {
            const visual = new MessageVisual_1.MessageVisual('aedsgrf');
            const discordChannel = new DiscordChannel_1.DiscordChannel({});
            const createdMessage = {
                content: 'bar'
            };
            jest.spyOn(discordChannel, 'sendMessageVisual')
                .mockResolvedValue(createdMessage);
            const storeMessages = jest.spyOn(discordChannel, 'storeMessages')
                .mockImplementation();
            // Send
            yield discordChannel.send(visual);
            expect(storeMessages).toHaveBeenCalledWith(createdMessage);
        }));
        it('saves each message if an array of messages is sent', () => __awaiter(void 0, void 0, void 0, function* () {
            const visual = new MessageVisual_1.MessageVisual('aedsgrf');
            const discordChannel = new DiscordChannel_1.DiscordChannel({});
            const createdMessages = [{
                    content: 'a'
                }, {
                    content: 'b'
                }];
            jest.spyOn(discordChannel, 'sendMessageVisual')
                .mockResolvedValue(createdMessages);
            const storeMessages = jest.spyOn(discordChannel, 'storeMessages')
                .mockImplementation();
            // Send
            yield discordChannel.send(visual);
            expect(storeMessages).toHaveBeenCalledWith(createdMessages);
        }));
        it('saves the message for sendMenuVisual', () => __awaiter(void 0, void 0, void 0, function* () {
            const visual = new MenuVisual_1.MenuVisual(new MenuEmbed_1.MenuEmbed());
            // Create the channel
            const discordChannel = new DiscordChannel_1.DiscordChannel({});
            const createdMessage = {
                content: 'bar'
            };
            // Mock the method
            jest.spyOn(discordChannel, 'sendMenuVisual')
                .mockResolvedValue(createdMessage);
            const storeMessages = jest.spyOn(discordChannel, 'storeMessages')
                .mockImplementation();
            // Send
            yield discordChannel.send(visual);
            expect(storeMessages).toHaveBeenCalledWith(createdMessage);
        }));
    });
});
