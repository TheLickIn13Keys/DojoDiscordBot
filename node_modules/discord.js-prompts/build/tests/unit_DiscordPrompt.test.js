"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const DiscordPrompt_1 = require("../DiscordPrompt");
const MessageVisual_1 = require("../visuals/MessageVisual");
const prompt_anything_1 = require("prompt-anything");
const MenuVisual_1 = require("../visuals/MenuVisual");
const MenuEmbed_1 = require("../MenuEmbed");
const discord_js_1 = require("discord.js");
const DiscordRejection_1 = require("../types/DiscordRejection");
const utils_1 = require("ts-jest/utils");
jest.mock('../visuals/MessageVisual');
const mockedMessageVisual = utils_1.mocked(MessageVisual_1.MessageVisual);
class MockCollector extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.stop = jest.fn();
    }
}
describe('Unit::DiscordPrompt', () => {
    let visual;
    let prompt;
    afterEach(function () {
        jest.resetAllMocks();
        mockedMessageVisual.mockReset();
    });
    beforeEach(() => {
        visual = new MessageVisual_1.MessageVisual('aedsg');
        prompt = new DiscordPrompt_1.DiscordPrompt(visual);
    });
    describe('constructor', () => {
        it('sets the default duration', () => {
            const prompt = new DiscordPrompt_1.DiscordPrompt(visual);
            expect(prompt.duration).toEqual(90000);
        });
        it('sets the passed in duration', () => {
            const prompt = new DiscordPrompt_1.DiscordPrompt(visual, undefined, 5);
            expect(prompt.duration).toEqual(5);
        });
    });
    describe('static getRejectVisual', () => {
        it('returns correctly for regular rejection', () => __awaiter(void 0, void 0, void 0, function* () {
            const text = 'err text';
            const rejection = new prompt_anything_1.Rejection(text);
            const result = yield DiscordPrompt_1.DiscordPrompt.getRejectVisual(rejection);
            expect(result).toBeInstanceOf(MessageVisual_1.MessageVisual);
            expect(mockedMessageVisual).toHaveBeenCalledWith(text);
        }));
        it('returns correctly for DiscordRejection', () => __awaiter(void 0, void 0, void 0, function* () {
            const text = 'error text';
            const embed = new discord_js_1.MessageEmbed();
            const rejection = new DiscordRejection_1.DiscordRejection(text, embed);
            const visual = yield DiscordPrompt_1.DiscordPrompt.getRejectVisual(rejection);
            expect(visual).toBeInstanceOf(MessageVisual_1.MessageVisual);
            expect(mockedMessageVisual).toHaveBeenCalledWith(text, {
                embed,
            });
        }));
    });
    describe('static createMenuRejection', () => {
        it('returns correctly', () => {
            const result = DiscordPrompt_1.DiscordPrompt.createMenuRejection();
            expect(result).toBeInstanceOf(prompt_anything_1.Rejection);
        });
    });
    describe('createCollector', () => {
        let createdCollector;
        const discordChannel = {
            channel: {
                createMessageCollector: jest.fn()
            },
            storeMessages: jest.fn()
        };
        beforeEach(() => {
            createdCollector = new MockCollector();
            discordChannel.channel.createMessageCollector = jest.fn()
                .mockReturnValue(createdCollector);
            jest.spyOn(prompt, 'handleMessage')
                .mockResolvedValue();
        });
        it('returns an event emitter', () => {
            const returned = prompt.createCollector(discordChannel, {
                __authorID: 'asde'
            });
            expect(returned).toBeInstanceOf(events_1.EventEmitter);
        });
        it('calls stops collector once emitter is stopped', () => {
            const emitter = prompt.createCollector(discordChannel, {
                __authorID: 'azsf'
            });
            emitter.emit('stop');
            expect(createdCollector.stop).toHaveBeenCalledTimes(1);
        });
        it('calls handle message for every message in collector', () => {
            const handleMessage = jest.spyOn(prompt, 'handleMessage')
                .mockResolvedValue();
            const data = {
                __authorID: 'bar'
            };
            const emitter = prompt.createCollector(discordChannel, data);
            const message = {};
            createdCollector.emit('collect', message);
            expect(handleMessage).toHaveBeenCalledWith(message, data, emitter);
        });
        it('stores the message for every message collected', () => {
            jest.spyOn(prompt, 'handleMessage')
                .mockResolvedValue();
            const data = {
                __authorID: 'bar'
            };
            prompt.createCollector(discordChannel, data);
            const message = {};
            createdCollector.emit('collect', message);
            expect(discordChannel.storeMessages)
                .toHaveBeenCalledWith(message);
        });
    });
    describe('handleMessage', () => {
        it('emits exit when message content is exit', () => __awaiter(void 0, void 0, void 0, function* () {
            const emitter = {
                emit: jest.fn()
            };
            const message = {
                content: 'exit'
            };
            yield prompt.handleMessage(message, {}, emitter);
            expect(emitter.emit).toHaveBeenCalledWith('exit');
        }));
        it('emits message if visual is not a menu', () => __awaiter(void 0, void 0, void 0, function* () {
            const messageVisual = new MessageVisual_1.MessageVisual('dh');
            jest.spyOn(prompt, 'getVisual')
                .mockResolvedValue(messageVisual);
            const emitter = {
                emit: jest.fn()
            };
            const message = {
                content: 'dfht'
            };
            yield prompt.handleMessage(message, {}, emitter);
            expect(emitter.emit).toHaveBeenCalledWith('message', message);
        }));
        it('calls handleMenuMessage if visual is a menu', () => __awaiter(void 0, void 0, void 0, function* () {
            const messageVisual = new MenuVisual_1.MenuVisual(new MenuEmbed_1.MenuEmbed());
            jest.spyOn(prompt, 'getVisual').mockResolvedValue(messageVisual);
            const handleMenuMessage = jest.spyOn(prompt, 'handleMenuMessage')
                .mockImplementation();
            const emitter = {
                emit: jest.fn()
            };
            const message = {
                content: 'dfht'
            };
            yield prompt.handleMessage(message, {}, emitter);
            expect(handleMenuMessage).toHaveBeenCalled();
            expect(emitter.emit).not.toHaveBeenCalled();
        }));
        it('emits error when getVisual fails', () => __awaiter(void 0, void 0, void 0, function* () {
            const error = new Error('awstgedr');
            jest.spyOn(prompt, 'getVisual')
                .mockRejectedValue(error);
            const emitter = {
                emit: jest.fn()
            };
            const message = {
                content: 'dfht'
            };
            yield prompt.handleMessage(message, {}, emitter);
            expect(emitter.emit).toHaveBeenCalledWith('error', error);
        }));
    });
    describe('handleMenuMessage', () => {
        it('emits reject if content is invalid', () => {
            const menuEmbed = new MenuEmbed_1.MenuEmbed();
            menuEmbed.isValidSelection = jest.fn().mockReturnValue(false);
            const createdRejection = new prompt_anything_1.Rejection('aqetsw6y4r75th');
            jest.spyOn(DiscordPrompt_1.DiscordPrompt, 'createMenuRejection')
                .mockReturnValue(createdRejection);
            const emitter = {
                emit: jest.fn()
            };
            const message = {
                content: 'dfht'
            };
            prompt.handleMenuMessage(message, {}, menuEmbed, emitter);
            expect(emitter.emit).toHaveBeenCalledWith('reject', message, createdRejection);
        });
        it('emits message if content is valid', () => {
            const menuEmbed = new MenuEmbed_1.MenuEmbed();
            menuEmbed.isValidSelection = jest.fn().mockReturnValue(true);
            const emitter = {
                emit: jest.fn()
            };
            const message = {
                content: 'dfht'
            };
            prompt.handleMenuMessage(message, {}, menuEmbed, emitter);
            expect(emitter.emit).toHaveBeenCalledWith('message', message);
        });
    });
    describe('onReject', () => {
        beforeEach(() => {
            jest.spyOn(prompt, 'sendVisual').mockResolvedValue({});
        });
        it('sends the reject visual', () => __awaiter(void 0, void 0, void 0, function* () {
            const message = {
                aaa: 'bbb'
            };
            const sendVisual = jest.spyOn(prompt, 'sendVisual');
            const channel = {
                foo: 'ade'
            };
            const data = {
                asdg: 'kghfdg'
            };
            const rejection = new prompt_anything_1.Rejection('sgrf');
            const rejectVisual = new MessageVisual_1.MessageVisual('srfg');
            const getRejectVisual = jest.spyOn(DiscordPrompt_1.DiscordPrompt, 'getRejectVisual')
                .mockResolvedValue(rejectVisual);
            yield prompt.onReject(rejection, message, channel, data);
            expect(sendVisual).toHaveBeenCalledWith(rejectVisual, channel);
            expect(getRejectVisual).toHaveBeenCalledWith(rejection, message, channel, data);
        }));
    });
});
